# System Architecture Directions for Networked Sensors (2000)
Traditional OS models were not fit for the constrained resources available on low-power, integrated networked sensor nodes. TinyOS is a tiny **event-driven** operating system that provides support for efficient modularity and **concurrency-intensive** operation that fits for this context. 

_The key requirements_ under this type of low power wireless communication environment are
1. _Resource Efficiency_: Sensor nodes are constrained by power, computation, and storage resources
2. _Modularity_: Easy to compose yet sufficiently decoupled components.
3. _Fine-grained concurrency_: sensing, processing, and communication
    1. information may be simultaneously captured from sensors, manipulated, and streamed onto a network 


## Key Ideas 
* Support concurrency
    * Event-driven architecture: high performance in concurrency intensive application! 
    * Why not thread?
       * stack-based: reserved for each execution context
       * need to be multi-task between execution contexts at rate of 40,000 switches per second  
* Software modularity
    *  Application = scheduler + graph of components
    *  _Component_: command handlers, event handlers, fixed-size frame, simple tasks
        * declare commands it uses and events it signals
        * provide interfaces used by other components to communicate with it  
    *  _Scheduler_: schedules the components 
*  Efficiency
    *  Get done quickly and then sleep
    *  Static memory allocation
        *  No heap (malloc), no function pointers, no dynamic runtime allocation    

### Component
A component is an independent computational entity that exposes one or more interfaces 

* Frame (storage) 
* Command: cause actions to be initiated 
   * deposit request parameters into frame, post tasks 
* Event: 
   * notify action has occured
   * generated by external interrupts
   * call back to provide results from previous commands 
* Task (computation): perform the primary work
   * background computation, not time critical 
   * task scheduler: FIFO  

<img width="288" alt="image" src="https://github.com/lynnliu030/os-prelim/assets/39693493/2ecada51-d8c0-4aa5-af93-26958388d6d5">


## Compared 
> TinyOS: The problem we must tackle is strikingly similar to that of building efficient network interfaces, which also must maintain a large number of concurrent flows and juggle numerous outstanding events

* Thread-based model: scheduler activations, cappricio
* Event-based system like TinyOS: SEDA
* Monolithic architecture class 
